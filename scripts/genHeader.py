# Generates functions.hpp that declares all uking functions in a header and has LinkerHints to generate a linker script from that
import os, csv

# consts
CUSTOM_HEADER = """
/*
 *  This file is generated from uking_functions.csv
 *  DO NOT EDIT THIS FILE DIRECTLY
 *  Generate with genHeader.py instead
 */

"""

# Namespace for the generated header
HPP_NAMESPACE = "ukr150"
# Prefix when function name starts with _
FUNC_PREFIX = "ukr"
# LinkerHints
LINKER_HINTS = "LinkerHints"

UKING_FUNCTIONS = "uking_functions.csv"
HPP_OUTPUT = f"include/{HPP_NAMESPACE}.hpp"

def cleanFunctionName(funcName):
    name = funcName.replace("::", "__")
    name = name.replace(".", "_")
    if name.startswith("_"):
        name = FUNC_PREFIX + name
    return name

def addFunctionDeclaration(hppLines, addrStr, funcName):
    cleanName = cleanFunctionName(funcName)
    mangledName = mangleFunctionName(cleanName)
    comment = f"/* {LINKER_HINTS} {addrStr} {mangledName} {funcName} */"
    declaration = f"extern void {cleanName}();"

    hppLines.append(comment)
    hppLines.append(declaration)

def mangleFunctionName(cleanName):
    return "_ZN" + str(len(HPP_NAMESPACE)) + HPP_NAMESPACE + str(len(cleanName)) + cleanName + "Ev"

def parseAddress(rawAddr):
    return "0x" + rawAddr[10:]

hppLines = []

# Open csv
with open(UKING_FUNCTIONS) as csvfile:
    reader = csv.reader(csvfile)
    for row in reader:
        rawAddr = row[0]
        # Skip the headers
        if rawAddr == "Address":
            continue
        funcName = row[3]
        if len(funcName) > 0:
            addrStr = parseAddress(rawAddr)
            addFunctionDeclaration(hppLines, addrStr, funcName)

# Write Hpp
with open(HPP_OUTPUT, "w") as hppFile:
    hppFile.write(f"/* {HPP_OUTPUT} */\n")
    hppFile.write(CUSTOM_HEADER)

    hppFile.write(f"namespace {HPP_NAMESPACE} {{\n")
    for line in hppLines:
        hppFile.write(line)
        hppFile.write("\n")
    hppFile.write("}\n")

